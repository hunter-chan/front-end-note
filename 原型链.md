#### 描述一下原型链

在JavaScript中，对象中，均有一个[[prototype]] (\_\_proto\_\_)对象指向其原型对象，新创建的没指定原型对象的对象，他们的原型都是Object，而Object的[[prototype]]则是null，对象可以通过Object.getPrototypeOf()来获取其原型对象。当为了访问某个对象的某个属性或者某个方法的时候，首先会在其自身的属性中找，如果没有找到，则会沿着原型链上的对象去找，如果找到，则返回，如果一直到null都没有找到，则不存在改属性或者方法。



方法的原型对象是Function.prorotype，Function的原型对象是Object.prototype。



在理解原型链的时候很容易受到影响的是方法中的prototype属性，prototype只是方法中才有的属性。一个方法在创造出来之后，是可以作为一个类来使用的，而通过new出来的对象，假设为a，则该方法的prototype对象b 是a的原型对象，而b的构造方法则指向该方法。b对象也称为该方法的原型对象。（尝试画图）



ES6中使用了class，则是ES5中类的一个语法糖。

[详细的例子](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)



ES5继承的实现，需要注意构造器的重新指向，以及父类构造方法的调用

```javascript
function Person(name, gender, age){
  this.name = name;
  this.gender = gender;
  this.age = age;
}
Person.prototype.greeting = function(){
  console.log(`Hi, I am ${this.name}`);
}
Person.prototype.working = function(){
  console.log(`I have no work now`);
}

function Programer(name, gender, age, language){
  Person.call(this, name, gender, age);
  this.language = language;
}

Programer.prototype = Object.create(Person.prototype);

Programer.constructor = Programer;

Programer.prototype.working = function(){
  console.log(`I am a programer, I use ${this.language}`)
}

let programer = new Programer('Jerry', 'female', 22, 'JavaScript');
programer.greeting() //  Hi, I am Jerry
programer.working() //  I am a programer, I use JavaScript
```

ES6的继承方式

```javascript
class Person{
  constructor(name, gender, age){
    this.name = name;
    this.gender = gender;
    this.age = age;
  }
  greeting = function(){
    console.log(`Hi, I am ${this.name}`);
  }
  working = function(){
    console.log(`I have no work now`);
  }
}

class Programer extends Person{
  constructor(name, gender, age, language){
    super(name, gender, age);
    this.language = language;
  }
  working = function(){
    console.log(`I am a programer, I use ${this.language}`)
  }
}
```

[继承的官方文档](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Inheritance)