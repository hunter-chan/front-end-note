#### 谈谈JavaScript垃圾回收机制

JavaScript作为一门高级语言不需要我们对内存进行直接操作，引擎会自动对内存的内容进行管理，但是如果没有深入理解，操作不当，将可能导致出现一些内存问题，从而影响程序的使用体验。



内存的使用包括了申请，使用，释放。定义了对象，使用对象执行一些操作，不再使用时，自动释放。申请和使用很简单，主要在于释放空间以便后续的使用比较复杂。有下列几种算法，引用计数，标记清除，标记整理，增量标记。



引用计数算法，该算法为每一个对象保存了引用的次数，每当一个引用消失，则减一，当减为0时，则需要对该对象进行回收了，之后才释放内存。优点：不需要为垃圾回收单独准备一段时间来执行清理操作。缺点：a、需要使用额外的内存空间来存储引用次数。b、当两个对象相互引用的时候，就会造成内存泄漏。c、一个一个的对象被自动释放之后，会造成内存碎片。



标记清除算法，该算法分为两个过程，1、是标记对象是否已经成为垃圾，2、对垃圾对象进行回收处理。标记阶段：首先需要判断哪些是垃圾，js中认为是可以通过根对象（即全局对象）访问到的对象即为活动对象，将其做标记，其余的则被认为是垃圾。清除阶段：则会将所有未被标记的对象清除。优点：跟引用计数相对比，解决了其中的相互引用问题，以及浪费内存再进行存储引用次数的问题。缺点：会同样会造成内存碎片。



为了解决内存碎片而有了标记整理算法，该算法同标记清除，同样先将可达对象标记为活动对象，在一轮标记完成之后，则会将所有的活动对象进行内存的整理，保证内存中的空闲空间是连续的。由于每次都需要标记再进行整理，其实该算法还是有点问题的，每次都需要暂停JavaScript代码的执行来处理，在内存不大的情况想尚可接受，在内存增大的时候这个过程可能会变得明显。



为了解释增量标记，先解释一下V8引擎中的垃圾回收模型。V8引擎中的内存模型分为了老生代（1.4G）和新生代（32M），老生代空间比较大，存放生命周期稍微长一点的活动对象，新生代则是存放生命周期比较短的对象。新生代空间比较小，会分为两个等大的空间，分别为from和to，当前的活动的对象将都在from中去生成和操作，等到from满了的时候，会进行一次标记整理，但是这次是将其中的活动对象移动到to空间，这期间可能会有晋升的情况，即对象将进入老生代中。然后form和to互换身份，继续下去。因为空间比较小，所以执行下来的时间很短，可以不被感知。晋升的情况：a、当变量已经经历过了一次复制 b、to空间的使用占比超过了25%，之后的对象都将晋升。老生代的垃圾回收用到了增量标记，由于老生代空间比较大，不可能暂停来执行标记整理的，所以整个过程和js的执行是交替执行的，不会直接占用大量的资源来执行GC过程的。这样几次之后便标记完毕，然后再进行整理，即完成了GC过程。



什么时候会触发GC？ 每个平台的情况均不一样。代码执行栈的，原则上当某个上下文执行结束的时候即被回收（闭包情况除外）



熟知垃圾回收对于编写代码的帮助，尽量编写生命周期短的参数，防止长生命周期导致没法回收从而影响应用的执行。